<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D AI Agent - Tavily Assistant</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
        }

        #canvas-container {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .interface-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            z-index: 10;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.3);
        }

        .chat-display {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .message {
            margin-bottom: 15px;
            padding: 12px 16px;
            border-radius: 12px;
            animation: fadeIn 0.4s ease-in;
            line-height: 1.5;
        }

        .user-message {
            background: linear-gradient(135deg, rgba(64, 165, 255, 0.3) 0%, rgba(38, 128, 235, 0.2) 100%);
            margin-left: 20%;
            text-align: right;
            border: 1px solid rgba(64, 165, 255, 0.3);
        }

        .agent-message {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            margin-right: 20%;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .input-container {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        #user-input {
            flex: 1;
            padding: 15px 25px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            color: white;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #user-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: #40a5ff;
            box-shadow: 0 0 0 3px rgba(64, 165, 255, 0.2);
            transform: translateY(-2px);
        }

        .btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #40a5ff 0%, #2680eb 100%);
            border: none;
            border-radius: 30px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(64, 165, 255, 0.3);
            font-size: 16px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(64, 165, 255, 0.4);
            background: linear-gradient(135deg, #50b5ff 0%, #3690fb 100%);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .voice-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            font-size: 18px;
        }

        .voice-btn:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.15);
        }

        .voice-btn.active {
            background: linear-gradient(135deg, #ff4040 0%, #eb2680 100%);
            animation: pulse 1.5s infinite;
            transform: scale(1.1);
        }

        .settings-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(20px);
            padding: 25px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
            z-index: 20;
            min-width: 280px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 15;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            font-size: 18px;
        }

        .settings-btn:hover {
            transform: scale(1.1) rotate(90deg);
            background: rgba(255, 255, 255, 0.15);
        }

        .setting-item {
            margin-bottom: 20px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            opacity: 0.9;
            font-weight: 500;
        }

        .slider {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }

        .slider:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #40a5ff 0%, #2680eb 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(64, 165, 255, 0.4);
            transition: all 0.3s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 15px rgba(64, 165, 255, 0.6);
        }

        .status-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            opacity: 0.9;
            background: rgba(26, 26, 46, 0.8);
            padding: 10px 15px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            background: #40ff40;
            border-radius: 50%;
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px rgba(64, 255, 64, 0.5);
        }

        .mood-indicator {
            position: absolute;
            top: 80px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 24px;
            background: rgba(26, 26, 46, 0.8);
            padding: 10px 15px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(15px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
                transform: scale(1);
            }
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #40a5ff;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Enhanced scrollbar styling */
        .chat-display::-webkit-scrollbar {
            width: 8px;
        }

        .chat-display::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .chat-display::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, rgba(64, 165, 255, 0.3), rgba(38, 128, 235, 0.3));
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .chat-display::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, rgba(64, 165, 255, 0.5), rgba(38, 128, 235, 0.5));
        }

        /* Emotion styles */
        .agent-thinking {
            animation: float 2s ease-in-out infinite;
        }

        .agent-speaking {
            filter: brightness(1.2);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="status-indicator">
        <div class="status-dot"></div>
        <span>AI Agent Active</span>
    </div>

    <div class="mood-indicator" id="moodIndicator">
        😊 <span id="moodText">Ready</span>
    </div>

    <button class="settings-btn" onclick="toggleSettings()">⚙️</button>
    
    <div class="settings-panel" id="settingsPanel">
        <h3 style="margin-bottom: 25px; text-align: center;">Personalization</h3>
        
        <div class="setting-item">
            <label>Agent Color Theme</label>
            <input type="range" class="slider" id="hueSlider" min="0" max="360" value="210">
        </div>
        
        <div class="setting-item">
            <label>Animation Speed</label>
            <input type="range" class="slider" id="speedSlider" min="0.3" max="2.5" step="0.1" value="1">
        </div>
        
        <div class="setting-item">
            <label>Voice Pitch</label>
            <input type="range" class="slider" id="pitchSlider" min="0.5" max="2" step="0.1" value="1">
        </div>
        
        <div class="setting-item">
            <label>Voice Rate</label>
            <input type="range" class="slider" id="rateSlider" min="0.5" max="2" step="0.1" value="1">
        </div>

        <div class="setting-item">
            <label>Skin Tone</label>
            <input type="range" class="slider" id="skinSlider" min="0" max="5" step="1" value="2">
        </div>

        <div class="setting-item">
            <label>Agent Mood</label>
            <select id="moodSelect" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white;">
                <option value="happy">😊 Happy</option>
                <option value="neutral">😐 Neutral</option>
                <option value="excited">🤩 Excited</option>
                <option value="thoughtful">🤔 Thoughtful</option>
                <option value="friendly">😄 Friendly</option>
            </select>
        </div>
    </div>

    <div class="interface-container">
        <div class="chat-display" id="chatDisplay">
            <div class="message agent-message">Hello! I'm your enhanced AI assistant powered by Tavily. I'm here to help you with any questions or tasks you might have. Feel free to customize my appearance and behavior using the settings panel!</div>
        </div>
        
        <div class="input-container">
            <input type="text" id="user-input" placeholder="Ask me anything..." onkeypress="handleKeyPress(event)">
            <button class="btn" onclick="sendMessage()">Send</button>
            <button class="voice-btn" id="voiceBtn" onclick="toggleVoice()">🎤</button>
        </div>
    </div>

    <script>
        // Three.js setup
        let scene, camera, renderer, agent, clock;
        let animationSpeed = 1;
        let agentHue = 210;
        let currentMood = 'happy';
        let skinTones = [
            0xffdbac, // Light
            0xf1c27d, // Light-medium
            0xe0ac69, // Medium
            0xc68642, // Medium-dark
            0x8d5524, // Dark
            0x5c2e04  // Very dark
        ];
        let currentSkinTone = 2;
        
        // Speech synthesis
        let synth = window.speechSynthesis;
        let recognition;
        let isListening = false;
        let isSpeaking = false;
        
        // Tavily API configuration
        // For development: Replace 'YOUR_TAVILY_API_KEY_HERE' with your actual API key
        // For production: Use environment variables or a secure config system
        const TAVILY_API_KEY = 'YOUR_TAVILY_API_KEY_HERE';
        
        function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a2e, 15, 60);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 4);
            camera.lookAt(0, 1, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Enhanced lighting setup
            const ambientLight = new THREE.AmbientLight(0x404080, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(8, 12, 8);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Rim lighting for dramatic effect
            const rimLight1 = new THREE.DirectionalLight(0x40a5ff, 0.8);
            rimLight1.position.set(-5, 3, -5);
            scene.add(rimLight1);

            const rimLight2 = new THREE.DirectionalLight(0xff6040, 0.4);
            rimLight2.position.set(5, 2, -3);
            scene.add(rimLight2);
            
            // Create enhanced agent
            createAgent();
            
            // Add enhanced particles
            createParticles();
            
            // Add environment
            createEnvironment();
            
            clock = new THREE.Clock();
            animate();
        }
        
        function createAgent() {
            const agentGroup = new THREE.Group();
            
            // Create materials with improved aesthetics
            const skinMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(skinTones[currentSkinTone]),
                transparent: true,
                opacity: 0.98,
                shininess: 40,
                specular: 0x222222
            });
            
            const clothingMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(`hsl(${agentHue}, 55%, 50%)`),
                emissive: new THREE.Color(`hsl(${agentHue}, 70%, 10%)`),
                emissiveIntensity: 0.1,
                shininess: 90,
                transparent: true,
                opacity: 0.95
            });
            
            // Torso with better proportions
            const torsoGeometry = new THREE.CylinderGeometry(0.35, 0.4, 1.0, 16);
            const torso = new THREE.Mesh(torsoGeometry, clothingMaterial);
            torso.position.y = 1.0;
            torso.castShadow = true;
            agentGroup.add(torso);
            
            // Head with better shape
            const headGeometry = new THREE.SphereGeometry(0.28, 32, 32);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 1.75;
            head.scale.set(1, 1.1, 0.95); // Slightly elongated for human-like proportions
            head.castShadow = true;
            agentGroup.add(head);
            
            // Neck
            const neckGeometry = new THREE.CylinderGeometry(0.11, 0.14, 0.18, 12);
            const neck = new THREE.Mesh(neckGeometry, skinMaterial);
            neck.position.y = 1.55;
            neck.castShadow = true;
            agentGroup.add(neck);
            
            // Eyes with pupils and iris
            const eyeballGeometry = new THREE.SphereGeometry(0.055, 16, 16);
            const eyeballMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                shininess: 100
            });
            
            const leftEyeball = new THREE.Mesh(eyeballGeometry, eyeballMaterial);
            leftEyeball.position.set(-0.11, 1.8, 0.24);
            agentGroup.add(leftEyeball);
            
            const rightEyeball = new THREE.Mesh(eyeballGeometry, eyeballMaterial);
            rightEyeball.position.set(0.11, 1.8, 0.24);
            agentGroup.add(rightEyeball);
            
            // Pupils
            const pupilGeometry = new THREE.SphereGeometry(0.025, 12, 12);
            const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a2e });
            
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(-0.11, 1.8, 0.295);
            agentGroup.add(leftPupil);
            
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.11, 1.8, 0.295);
            agentGroup.add(rightPupil);
            
            // Iris glow
            const irisGeometry = new THREE.RingGeometry(0.018, 0.035, 12);
            const irisMaterial = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(`hsl(${agentHue}, 80%, 70%)`),
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            const leftIris = new THREE.Mesh(irisGeometry, irisMaterial);
            leftIris.position.set(-0.11, 1.8, 0.292);
            agentGroup.add(leftIris);
            
            const rightIris = new THREE.Mesh(irisGeometry, irisMaterial);
            rightIris.position.set(0.11, 1.8, 0.292);
            agentGroup.add(rightIris);
            
            // Eyebrows
            const eyebrowGeometry = new THREE.BoxGeometry(0.08, 0.02, 0.01);
            const eyebrowMaterial = new THREE.MeshPhongMaterial({ 
                color: new THREE.Color(skinTones[currentSkinTone]).multiplyScalar(0.7)
            });
            
            const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            leftEyebrow.position.set(-0.11, 1.85, 0.25);
            leftEyebrow.rotation.z = 0.1;
            agentGroup.add(leftEyebrow);
            
            const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            rightEyebrow.position.set(0.11, 1.85, 0.25);
            rightEyebrow.rotation.z = -0.1;
            agentGroup.add(rightEyebrow);
            
            // Arms with joints
            const upperArmGeometry = new THREE.CylinderGeometry(0.075, 0.095, 0.45, 12);
            const forearmGeometry = new THREE.CylinderGeometry(0.065, 0.075, 0.4, 12);
            
            // Left arm
            const leftUpperArm = new THREE.Mesh(upperArmGeometry, clothingMaterial);
            leftUpperArm.position.set(-0.42, 1.2, 0);
            leftUpperArm.rotation.z = Math.PI / 12;
            leftUpperArm.castShadow = true;
            agentGroup.add(leftUpperArm);
            
            const leftForearm = new THREE.Mesh(forearmGeometry, skinMaterial);
            leftForearm.position.set(-0.65, 0.85, 0.08);
            leftForearm.rotation.z = Math.PI / 8;
            leftForearm.castShadow = true;
            agentGroup.add(leftForearm);
            
            // Right arm
            const rightUpperArm = new THREE.Mesh(upperArmGeometry, clothingMaterial);
            rightUpperArm.position.set(0.42, 1.2, 0);
            rightUpperArm.rotation.z = -Math.PI / 12;
            rightUpperArm.castShadow = true;
            agentGroup.add(rightUpperArm);
            
            const rightForearm = new THREE.Mesh(forearmGeometry, skinMaterial);
            rightForearm.position.set(0.65, 0.85, 0.08);
            rightForearm.rotation.z = -Math.PI / 8;
            rightForearm.castShadow = true;
            agentGroup.add(rightForearm);
            
            // Hands
            const handGeometry = new THREE.SphereGeometry(0.055, 12, 12);
            const handMaterial = skinMaterial.clone();
            
            const leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.set(-0.78, 0.65, 0.12);
            leftHand.scale.set(1, 1.3, 0.8);
            leftHand.castShadow = true;
            agentGroup.add(leftHand);
            
            const rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.set(0.78, 0.65, 0.12);
            rightHand.scale.set(1, 1.3, 0.8);
            rightHand.castShadow = true;
            agentGroup.add(rightHand);
            
            // Legs
            const thighGeometry = new THREE.CylinderGeometry(0.11, 0.14, 0.55, 12);
            const shinGeometry = new THREE.CylinderGeometry(0.09, 0.11, 0.5, 12);
            
            // Left leg
            const leftThigh = new THREE.Mesh(thighGeometry, clothingMaterial);
            leftThigh.position.set(-0.14, 0.25, 0);
            leftThigh.castShadow = true;
            agentGroup.add(leftThigh);
            
            const leftShin = new THREE.Mesh(shinGeometry, clothingMaterial);
            leftShin.position.set(-0.14, -0.3, 0);
            leftShin.castShadow = true;
            agentGroup.add(leftShin);
            
            // Right leg
            const rightThigh = new THREE.Mesh(thighGeometry, clothingMaterial);
            rightThigh.position.set(0.14, 0.25, 0);
            rightThigh.castShadow = true;
            agentGroup.add(rightThigh);
            
            const rightShin = new THREE.Mesh(shinGeometry, clothingMaterial);
            rightShin.position.set(0.14, -0.3, 0);
            rightShin.castShadow = true;
            agentGroup.add(rightShin);
            
            // Feet
            const footGeometry = new THREE.BoxGeometry(0.14, 0.07, 0.22);
            const footMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2c3e50,
                shininess: 30
            });
            
            const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
            leftFoot.position.set(-0.14, -0.58, 0.04);
            leftFoot.castShadow = true;
            agentGroup.add(leftFoot);
            
            const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
            rightFoot.position.set(0.14, -0.58, 0.04);
            rightFoot.castShadow = true;
            agentGroup.add(rightFoot);
            
            // Add subtle aura effect around the agent
            const auraGeometry = new THREE.SphereGeometry(1.8, 32, 32);
            const auraMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(`hsl(${agentHue}, 60%, 50%)`),
                transparent: true,
                opacity: 0.03,
                side: THREE.BackSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            aura.position.y = 0.5;
            agentGroup.add(aura);
            
            // Store references for animation
            agentGroup.userData = {
                head: head,
                leftEye: leftPupil,
                rightEye: rightPupil,
                leftIris: leftIris,
                rightIris: rightIris,
                leftEyebrow: leftEyebrow,
                rightEyebrow: rightEyebrow,
                leftArm: leftUpperArm,
                rightArm: rightUpperArm,
                leftForearm: leftForearm,
                rightForearm: rightForearm,
                leftHand: leftHand,
                rightHand: rightHand,
                torso: torso,
                aura: aura
            };
            
            agent = agentGroup;
            scene.add(agent);
        }
        
        function createParticles() {
            const particlesGeometry = new THREE.BufferGeometry();
            const particleCount = 150;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            const color = new THREE.Color();
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 15;
                positions[i + 1] = Math.random() * 8;
                positions[i + 2] = (Math.random() - 0.5) * 15;
                
                color.setHSL((agentHue + Math.random() * 60) / 360, 0.7, 0.5);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.08,
                transparent: true,
                opacity: 0.8,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);
        }
        
        function createEnvironment() {
            // Create a subtle ground plane
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1a2e,
                transparent: true,
                opacity: 0.3,
                shininess: 100
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.7;
            ground.receiveShadow = true;
            scene.add(ground);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            if (agent && agent.userData) {
                const userData = agent.userData;
                
                // Enhanced idle animation based on mood
                const idleIntensity = getMoodIntensity();
                
                agent.rotation.y = Math.sin(time * 0.4 * animationSpeed) * 0.08 * idleIntensity;
                agent.position.y = Math.sin(time * 1.8 * animationSpeed) * 0.04 * idleIntensity;
                
                // Head movement
                if (userData.head) {
                    userData.head.rotation.x = Math.sin(time * 0.6 * animationSpeed) * 0.05 * idleIntensity;
                    userData.head.rotation.y = Math.sin(time * 0.3 * animationSpeed) * 0.1 * idleIntensity;
                }
                
                // Eye movement
                const eyeMovement = Math.sin(time * 0.8 * animationSpeed) * 0.02;
                if (userData.leftEye && userData.rightEye) {
                    userData.leftEye.position.x = -0.11 + eyeMovement;
                    userData.rightEye.position.x = 0.11 + eyeMovement;
                    userData.leftIris.position.x = -0.11 + eyeMovement;
                    userData.rightIris.position.x = 0.11 + eyeMovement;
                }
                
                // Eyebrow expressions based on mood
                if (userData.leftEyebrow && userData.rightEyebrow) {
                    const browMovement = getMoodBrowMovement(time);
                    userData.leftEyebrow.rotation.z = 0.1 + browMovement;
                    userData.rightEyebrow.rotation.z = -0.1 - browMovement;
                }
                
                // Arm animation
                if (userData.leftArm && userData.rightArm) {
                    userData.leftArm.rotation.x = Math.sin(time * 1.2 * animationSpeed) * 0.15 * idleIntensity;
                    userData.rightArm.rotation.x = -Math.sin(time * 1.2 * animationSpeed) * 0.15 * idleIntensity;
                }
                
                // Hand gestures when speaking
                if (isSpeaking && userData.leftHand && userData.rightHand) {
                    userData.leftHand.rotation.z = Math.sin(time * 3 * animationSpeed) * 0.2;
                    userData.rightHand.rotation.z = -Math.sin(time * 3 * animationSpeed) * 0.2;
                }
                
                // Breathing effect on torso
                if (userData.torso) {
                    userData.torso.scale.y = 1 + Math.sin(time * 2 * animationSpeed) * 0.02;
                }
                
                // Aura pulsing
                if (userData.aura) {
                    userData.aura.material.opacity = 0.03 + Math.sin(time * 1.5 * animationSpeed) * 0.02;
                }
            }
            
            renderer.render(scene, camera);
        }
        
        function getMoodIntensity() {
            switch (currentMood) {
                case 'excited': return 1.5;
                case 'happy': return 1.0;
                case 'friendly': return 1.2;
                case 'thoughtful': return 0.6;
                case 'neutral': return 0.8;
                default: return 1.0;
            }
        }
        
        function getMoodBrowMovement(time) {
            switch (currentMood) {
                case 'excited': return Math.sin(time * 2) * 0.1;
                case 'thoughtful': return -0.05 + Math.sin(time * 0.5) * 0.02;
                case 'happy': return Math.sin(time * 1.5) * 0.03;
                default: return 0;
            }
        }
        
        async function sendMessage() {
            const input = document.getElementById('user-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Check if API key is configured
            if (TAVILY_API_KEY === 'YOUR_TAVILY_API_KEY_HERE') {
                addMessage("⚠️ Please configure your Tavily API key in the code. Get your free API key at https://tavily.com/", 'agent');
                return;
            }
            
            // Add user message to chat
            addMessage(message, 'user');
            input.value = '';
            
            // Update mood to thinking
            updateMood('thoughtful', 'Thinking...');
            if (agent) agent.classList?.add('agent-thinking');
            
            // Show loading
            const loadingId = addMessage('<div class="loading"></div>', 'agent');
            
            try {
                // Call Tavily API
                const response = await fetch('https://api.tavily.com/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        api_key: TAVILY_API_KEY,
                        query: message,
                        search_depth: 'advanced',
                        max_results: 5,
                        include_answer: true
                    })
                });
                
                const data = await response.json();
                
                // Process and format response
                let agentResponse = processSearchResults(data, message);
                
                // Remove loading and add response
                removeMessage(loadingId);
                addMessage(agentResponse, 'agent');
                
                // Update mood to speaking
                updateMood('happy', 'Speaking...');
                if (agent) {
                    agent.classList?.remove('agent-thinking');
                    agent.classList?.add('agent-speaking');
                }
                
                // Speak the response
                speak(agentResponse);
                
            } catch (error) {
                console.error('Error:', error);
                removeMessage(loadingId);
                const fallbackResponse = "I'm having trouble accessing information right now. Let me try to help based on my general knowledge. What would you like to know?";
                addMessage(fallbackResponse, 'agent');
                updateMood('neutral', 'Ready');
                speak(fallbackResponse);
            }
        }
        
        function processSearchResults(data, query) {
            if (!data.results || data.results.length === 0) {
                return "I couldn't find specific information about that. Could you please rephrase your question or ask about something else?";
            }
            
            // Use the answer if available, otherwise format results
            if (data.answer) {
                return data.answer;
            }
            
            // Extract relevant information from search results
            const topResult = data.results[0];
            let response = `Based on my search, here's what I found about "${query}":\n\n`;
            response += topResult.content.substring(0, 300);
            
            // Add context from other results if available
            if (data.results.length > 1) {
                response += "\n\nAdditional information suggests that ";
                response += data.results[1].content.substring(0, 150) + "...";
            }
            
            return response;
        }
        
        function addMessage(text, sender) {
            const chatDisplay = document.getElementById('chatDisplay');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            messageDiv.innerHTML = text;
            messageDiv.id = `msg-${Date.now()}`;
            chatDisplay.appendChild(messageDiv);
            chatDisplay.scrollTop = chatDisplay.scrollHeight;
            return messageDiv.id;
        }
        
        function removeMessage(id) {
            const msg = document.getElementById(id);
            if (msg) msg.remove();
        }
        
        function speak(text) {
            if ('speechSynthesis' in window) {
                isSpeaking = true;
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.pitch = parseFloat(document.getElementById('pitchSlider').value);
                utterance.rate = parseFloat(document.getElementById('rateSlider').value);
                
                utterance.onend = function() {
                    isSpeaking = false;
                    updateMood('happy', 'Ready');
                    if (agent) agent.classList?.remove('agent-speaking');
                };
                
                synth.speak(utterance);
            }
        }
        
        function updateMood(mood, status) {
            currentMood = mood;
            const moodText = document.getElementById('moodText');
            const moodIndicator = document.getElementById('moodIndicator');
            
            if (moodText) moodText.textContent = status;
            
            const moodEmojis = {
                'happy': '😊',
                'excited': '🤩',
                'thoughtful': '🤔',
                'neutral': '😐',
                'friendly': '😄'
            };
            
            if (moodIndicator) {
                moodIndicator.innerHTML = `${moodEmojis[mood] || '😊'} <span id="moodText">${status}</span>`;
            }
        }
        
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                
                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    document.getElementById('user-input').value = transcript;
                    sendMessage();
                };
                
                recognition.onerror = function(event) {
                    console.error('Speech recognition error', event.error);
                    isListening = false;
                    updateVoiceButton();
                };
                
                recognition.onend = function() {
                    isListening = false;
                    updateVoiceButton();
                };
            }
        }
        
        function toggleVoice() {
            if (!recognition) {
                initSpeechRecognition();
            }
            
            if (isListening) {
                recognition.stop();
                isListening = false;
            } else {
                recognition.start();
                isListening = true;
            }
            updateVoiceButton();
        }
        
        function updateVoiceButton() {
            const voiceBtn = document.getElementById('voiceBtn');
            if (isListening) {
                voiceBtn.classList.add('active');
            } else {
                voiceBtn.classList.remove('active');
            }
        }
        
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }
        
        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        
        // Settings handlers
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('hueSlider').addEventListener('input', function(e) {
                agentHue = parseInt(e.target.value);
                updateAgentColor();
            });
            
            document.getElementById('speedSlider').addEventListener('input', function(e) {
                animationSpeed = parseFloat(e.target.value);
            });

            document.getElementById('skinSlider').addEventListener('input', function(e) {
                currentSkinTone = parseInt(e.target.value);
                updateSkinTone();
            });

            document.getElementById('moodSelect').addEventListener('change', function(e) {
                updateMood(e.target.value, 'Ready');
            });
        });
        
        function updateAgentColor() {
            if (agent && agent.children) {
                agent.children.forEach(child => {
                    if (child.material && child.material.color) {
                        const hsl = `hsl(${agentHue}, 55%, 50%)`;
                        if (child.material.color.getHexString() !== skinTones[currentSkinTone].toString(16)) {
                            child.material.color = new THREE.Color(hsl);
                            child.material.emissive = new THREE.Color(`hsl(${agentHue}, 70%, 10%)`);
                        }
                    }
                });
                
                // Update iris color
                if (agent.userData && agent.userData.leftIris && agent.userData.rightIris) {
                    const irisColor = new THREE.Color(`hsl(${agentHue}, 80%, 70%)`);
                    agent.userData.leftIris.material.color = irisColor;
                    agent.userData.rightIris.material.color = irisColor;
                }
            }
        }
        
        function updateSkinTone() {
            if (agent && agent.children) {
                const newSkinColor = new THREE.Color(skinTones[currentSkinTone]);
                agent.children.forEach(child => {
                    if (child.material && child.geometry && 
                        (child.geometry.type === 'SphereGeometry' || child.geometry.type === 'CylinderGeometry')) {
                        // Check if it's a skin part (not clothing)
                        const currentColor = child.material.color.getHex();
                        for (let tone of skinTones) {
                            if (Math.abs(currentColor - tone) < 0x100000) {
                                child.material.color = newSkinColor;
                                break;
                            }
                        }
                    }
                });
            }
        }
        
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Add mouse interaction for camera movement
        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', function(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            if (camera) {
                camera.position.x = mouseX * 0.5;
                camera.position.y = 1.5 + mouseY * 0.3;
                camera.lookAt(0, 1, 0);
            }
        });
        
        // Initialize
        init3D();
        initSpeechRecognition();
        updateMood('happy', 'Ready');
    </script>
</body>
</html>